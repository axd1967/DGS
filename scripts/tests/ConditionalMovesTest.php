<?php
/*
Dragon Go Server
Copyright (C) 2001-  Erik Ouchterlony, Jens-Uwe Gaspar

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* Author: Jens-Uwe Gaspar */

// Call ConditionalMovesTest::main() if this source file is executed directly.
if (!defined("PHPUnit_MAIN_METHOD")) {
   define("PHPUnit_MAIN_METHOD", "ConditionalMovesTest::main");
}

require_once "PHPUnit/Framework/TestCase.php";
require_once "PHPUnit/Framework/TestSuite.php";

require_once 'include/conditional_moves.php';
require_once 'include/coords.php';



/**
 * Test class for ConditionalMoves.
 * Generated by PHPUnit_Util_Skeleton on 2014-05-22 at 14:49:56.
 */
class ConditionalMovesTest extends PHPUnit_Framework_TestCase {

   /**
    * Runs the test methods of this class.
    *
    * @access public
    * @static
    */
   public static function main() {
      require_once "PHPUnit/TextUI/TestRunner.php";

      $suite  = new PHPUnit_Framework_TestSuite("ConditionalMovesTest");
      $result = PHPUnit_TextUI_TestRunner::run($suite);
   }

   /** Tests reformat_to_sgf(). */
   public function test_reformat_to_sgf() {
      $sgf = '(;B[r14];W[n16];B[s16];W[r17];B[r11])';
      $this->assertEquals( '', ConditionalMoves::reformat_to_sgf( '', 19, true ) );
      $this->assertEquals( $sgf, ConditionalMoves::reformat_to_sgf( $sgf, 19, true ) );

      $this->assertEquals( '(;B[r14] ;W[n16] ;B[s16] ;W[r17] ;B[r11] )',
         ConditionalMoves::reformat_to_sgf( 'r14 n16 s16 r17 r11', 19, true ) );
      $this->assertEquals( '(;W[r14] ;B[n16] ;W[s16] ;B[r17] ;W[r11] )',
         ConditionalMoves::reformat_to_sgf( 'r14 n16 s16 r17 r11', 19, false ) );
   }//test_reformat_to_sgf

   /** Tests check_nodes_cond_moves(). */
   public function test_check_nodes_cond_moves() {
      $board = new Board( 0, 19 );
      $board->init_board();
      $gchkmove = new GameCheckMove( $board );
      $gchkmove->replay_move( 'Bqq' ); // play 1st move

      $sgf = '(;W[hj];B[aa];W[bb](;B[cc];W[dd](;B[ee];W[ff])(;B[kk];W[gg]))(;B[hh];W[];B[ii]))';
      $game_tree = $this->get_sgf_parser( $sgf );
      list( $errors, $var_refs, $sgf_out ) = ConditionalMoves::check_nodes_cond_moves( $game_tree, $gchkmove, 19, WHITE );
      $this->assertEquals( '', implode('; ', $errors) );
      $this->assertEquals( '1.1.1 / 1.1.2 / 1.2', implode(' / ', $var_refs) );
      $this->assertEquals( $sgf, $sgf_out );

      //TODO TODO fix: should be able to start with BLACK on 1st move !?
      //TODO TODO test various errors of func

   }//test_check_nodes_cond_moves

   /** Tests extract_variation(). */
   public function test_extract_variation() {
      // vars: 1.1.1 ( = 1.1 = 1 ); 1.1.2 ; 1.2
      $sgf = '(;B[aa];W[bb](;B[cc];W[dd](;B[ee];W[ff])(;B[ee];W[gg]))(;B[hh];W[];B[ii]))';
      $game_tree = $this->get_sgf_parser( $sgf );

      $this->assertEquals( 'Baa,Wbb,Bcc,Wdd,Bee,Wff',
         $this->var2text( ConditionalMoves::extract_variation( $game_tree, '1', 19 ) ));
      $this->assertEquals( 'Baa,Wbb,Bcc,Wdd,Bee,Wff',
         $this->var2text( ConditionalMoves::extract_variation( $game_tree, '1.1', 19 ) ));
      $this->assertEquals( 'Baa,Wbb,Bcc,Wdd,Bee,Wff',
         $this->var2text( ConditionalMoves::extract_variation( $game_tree, '1.1.1', 19 ) ));
      $this->assertEquals( 'Baa,Wbb,Bcc,Wdd,Bee,Wgg',
         $this->var2text( ConditionalMoves::extract_variation( $game_tree, '1.1.2', 19 ) ));
      $this->assertEquals( 'Baa,Wbb,Bhh,W,Bii',
         $this->var2text( ConditionalMoves::extract_variation( $game_tree, '1.2', 19 ) ));

      // errors
      $this->assertEquals( "Variation reference [2.1] must start with '1'.",
         ConditionalMoves::extract_variation( $this->get_sgf_parser( $sgf ), '2.1', 19 ) );
      $this->assertEquals( 'Sub-variation [1.1.3] can not be found.',
         ConditionalMoves::extract_variation( $this->get_sgf_parser( $sgf ), '1.1.3', 19 ) );

      $sgf = '(;B[aa];W[bb](;B[cc];W[dd](;B[ee];W[ff])(;B[ee];W[gg]))(;B[hh];W[];B[ii]))';
      $game_tree = $this->get_sgf_parser( $sgf );
      $this->assertEquals( 'Illegal coordinate found [hh] in sub-variation [1.2].',
         ConditionalMoves::extract_variation( $game_tree, '1.2', 7 ) );
      $this->assertEquals( 'Baa,Wbb,Bcc,Wdd,Bee,Wgg',
         $this->var2text( ConditionalMoves::extract_variation( $game_tree, '1.1.2', 7 ) ) );
   }//test_extract_variation

   /** Tests fill_conditional_moves_attributes(). */
   public function test_fill_conditional_moves_attributes() {
      $sgf = '(;AB[aa][bb][cc];B[aa];W[bb];B[];W[])';
      $game_tree = $this->get_sgf_parser( $sgf );
      $game_tree2 = ConditionalMoves::fill_conditional_moves_attributes( $game_tree, 5 );
      $this->assertEquals(
         '{props=AB[aa][bb][cc], pos=[1], move_nr=[5]} ' .
         '{props=B[aa], pos=[16], move_nr=[6], sgf_move=[Baa]} ' .
         '{props=W[bb], pos=[22], move_nr=[7], sgf_move=[Wbb]} ' .
         '{props=B[], pos=[28], move_nr=[8], sgf_move=[B]} ' .
         '{props=W[], pos=[32], move_nr=[9], sgf_move=[W]}',
         $this->tree2text($game_tree2));

      $sgf = '(;B[aa];W[bb](;B[cc];W[dd](;B[ee];W[ff])(;B[ee];W[gg])))';
      $game_tree = $this->get_sgf_parser( $sgf );
      $game_tree2 = ConditionalMoves::fill_conditional_moves_attributes( $game_tree, 1 );
      $this->assertEquals(
         '{props=B[aa], pos=[1], move_nr=[1], sgf_move=[Baa]} ' .
         '{props=W[bb], pos=[7], move_nr=[2], sgf_move=[Wbb]} ' .
            '<{props=B[cc], pos=[14], move_nr=[3], sgf_move=[Bcc]} {props=W[dd], pos=[20], move_nr=[4], sgf_move=[Wdd]} ' .
               '<{props=B[ee], pos=[27], move_nr=[5], sgf_move=[Bee]} {props=W[ff], pos=[33], move_nr=[6], sgf_move=[Wff]}> ' .
               '<{props=B[ee], pos=[41], move_nr=[5], sgf_move=[Bee]} {props=W[gg], pos=[47], move_nr=[6], sgf_move=[Wgg]}>>',
         $this->tree2text($game_tree2));

      $this->assertEquals( $this->tree2text($game_tree), $this->tree2text($game_tree2) );
   }//test_fill_conditional_moves_attributes


   private function get_sgf_parser( $sgf )
   {
      $parser = SgfParser::sgf_parser( $sgf, SGFP_OPT_SKIP_ROOT_NODE );
      $this->assertEquals( '', $parser->error_msg );
      $this->assertEquals( 1, count($parser->games) );
      return $parser->games[0];
   }

   private function tree2text( $game_tree )
   {
      $out = array();
      foreach ( $game_tree->nodes as $node )
         $out[] = $node->to_string();
      foreach ( $game_tree->vars as $sub_tree )
         $out[] = "<" . $this->tree2text($sub_tree) . ">";
      return implode(' ', $out);
   }

   private function var2text( $arr_moves, $size=19 )
   {
      $out = array();
      foreach ( $arr_moves as $arr )
      {
         list( $stone, $x, $y ) = $arr;
         $out[] = ( $stone == BLACK ? 'B' : 'W' ) . ( $x == POSX_PASS ? '' : number2sgf_coords($x,$y,$size) );
      }
      return implode(',', $out);
   }

}

// Call ConditionalMovesTest::main() if this source file is executed directly.
if (PHPUnit_MAIN_METHOD == "ConditionalMovesTest::main") {
   ConditionalMovesTest::main();
}
?>
